package torch.model;

import torch.IModel;
import torch.Record;
import torch.RecordComparator;
import torch.counter.Counter;

/**
 * An object that represents a multinomial mixture model under the conditional independence (CI)
 * assumption. Under this model, comparison patterns are generated by a mixture of latent classes.
 * Given a latent class, the variates in a comparison pattern are independent.
 */
public class MixtureModel
    implements IModel
{

    /**
     * Uses unsupervised learning to fit a two-class mixture model to unlabeled data. A mixture
     * model with two classes is fit, and the class with the lower class weight is declared to
     * be the match class.
     */
    public static MixtureModel fit(Counter counter) {
        UnsupervisedLearner lr = new UnsupervisedLearner(counter, 2);
        double[] classWeights = lr.classWeights();
        if (classWeights[0] < classWeights[1])
            lr.setMatchClass(0, true);
        else
            lr.setMatchClass(1, true);

        return lr.model();
    }

    /**
     * Uses supervised learning to fit a mixture model to labeled data.
     */
    public static MixtureModel fit(Counter[] counter, int nMatchClasses)
    {
        return new SupervisedLearner(counter, nMatchClasses).model();
    }

    /**
     * Uses semisuvervised learning to fit a mixture model to a mix of labeled and unlabeled
     * data.
     */
    public static MixtureModel fit(Counter unlabeled, Counter[] labeled, 
                                   int nMatchClasses, double lambda)
    {
        return new SemisupervisedLearner(unlabeled, labeled, nMatchClasses, lambda).model();
    }

    /**
     * Computes posterior mean parameters.
     */
    public static MixtureModel posterior(MixtureModelPrior prior, Counter counter) {
        return new UnsupervisedBayes(prior, counter).model();
    }

    public MixtureModel(RecordComparator comparator, double[][][] mWeights, int nMatchClasses) {
        _cmp = comparator;
        _mWeights = mWeights;
        _nClasses = mWeights.length;
        _nMatchClasses = nMatchClasses;

        if (_nClasses < 2)
            throw new IllegalArgumentException("need at least two classes");

        if (nMatchClasses == _nClasses)
            throw new IllegalArgumentException("need at least one nonmatch class");

        // check the dimensions of mWeights
        String err1 = "mWeights[%d].length incompatible with comparator";
        String err2 = "mWeights[%d][%d].length incompatible with comparator";
        for (int j = 0; j < _nClasses; j++) {
            if (mWeights[j].length != _cmp.nComparators())
                throw new IllegalArgumentException(String.format(err1, j));
            for (int k = 0; k < _cmp.nComparators(); k++)
                if (mWeights[j][k].length != _cmp.nLevels(k))
                    throw new IllegalArgumentException(String.format(err2, j, k));
        }

        // compute the log-weights
        _logMWeights = new double[_nClasses][_cmp.nComparators()][];
        for (int j = 0; j < _nClasses; j++) {
            for (int k = 0; k < _cmp.nComparators(); k++) {
                _logMWeights[j][k] = new double[_cmp.nLevels(k)];
                for (int x = 0; x < _cmp.nLevels(k); x++) {
                    _logMWeights[j][k][x] = Math.log(_mWeights[j][k][x]);
                }
            }
        }
    }

    public int nClasses() {
        return _nClasses;
    }

    public int nMatchClasses() {
        return _nMatchClasses;
    }

    public double[][][] multinomialWeights() {
        return _mWeights;
    }

    @Override
    public double matchScore(Record rec1, Record rec2) {
        double score = 0.0;
        int[] pattern = _cmp.compare(rec1, rec2);

        for (int j = 0; j < _nMatchClasses; j++) {
            for (int k = 0; k < _cmp.nComparators(); k++)
                score += _logMWeights[j][k][pattern[k]];
        }

        for (int j = _nMatchClasses; j < _nClasses; j++) {
            for (int k = 0; k < _cmp.nComparators(); k++)
                score -= _logMWeights[j][k][pattern[k]];
        }

        return score;
    }

    @Override
    public RecordComparator recordComparator() {
        return _cmp;
    }

    @Override
    public String toString() {
        int precision = 4;
        StringBuilder builder = new StringBuilder();
        builder.append(String.format("Model: multinomial mixture (CI) with %d classes%n", _nClasses));

        for (int j = 0; j < _nClasses; j++) {
            builder.append(String.format("Class %2d:%n", j));
            builder.append(String.format("%-7s%s%n", "Field", "Weights"));

            for (int k = 0; k < _cmp.nComparators(); k++) {
                builder.append(String.format("%-7d", k));
                for (int x = 0; x < _cmp.nLevels(k); x++)
                    builder.append(String.format("%6.4f ", _mWeights[j][k][x]));

                builder.append("\n");
            }
        }

        return builder.toString();
    }

    private final RecordComparator _cmp;
    private final int _nClasses, _nMatchClasses;
    private final double[][][] _mWeights, _logMWeights;
}
